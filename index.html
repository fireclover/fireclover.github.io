<head>
  <style> body { margin: 0; } </style>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="icons/favicon.ico">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>

  <script>var baseUrl="https://fireclover.imk.im/_db/demo/demo/"</script>
  <script src="https://fireclover.imk.im/_db/demo/demo/js/dat.gui"></script>
  <script src="https://fireclover.imk.im/_db/demo/demo/js/3d-force-graph"></script>
  <script src="https://fireclover.imk.im/_db/demo/demo/js/three"></script>
  <!--<script src="https://unpkg.com/three-spritetext"></script>
  <script src="https://unpkg.com/three/examples/js/renderers/CSS2DRenderer.js"></script>-->


  <!--<script src="//unpkg.com/d3-dsv"></script>
  <script src="//unpkg.com/d3-octree"></script>
  <script src="//unpkg.com/d3-force-3d"></script>-->
  
  <style>
    .node-label {
      font-size: 12px;
      padding: 1px 4px;
      border-radius: 4px;
      background-color: rgba(0,0,0,0.5);
      user-select: none;
    }
  </style>

</head>

<body>
  <div id="3d-graph"></div>

  <script>
    Array.prototype.unique_nodes = function() {
      if (this == undefined) {
          return [];
      }
      var a = this.concat();
      for(var i=0; i<a.length; ++i) {
          for(var j=i+1; j<a.length; ++j) {
              if(a[i] == undefined || a[j] == undefined || a[i].id === a[j].id || a[i]._id === a[j]._id || a[i] === a[j].id || a[j] === a[i].id)
                  a.splice(j--, 1);
          }
      }
      return a;
    };
    
    Array.prototype.unique_links = function() {
      if (this == undefined) {
          return [];
      }
      var a = this.concat();
      for(var i=0; i<a.length; ++i) {
        if (a[i]) {
          for(var j=i+1; j<a.length; ++j) {

              if( //a[i] || 
                (a[i].source == a[j].source && a[i].target == a[j].target) || 
                (a[i].source._id && a[i].target._id && a[i].source._id == a[j].source && a[i].target._id == a[j].target) || 
                (a[j].source._id && a[j].target._id && a[i].source == a[j].source._id && a[i].target == a[j].target._id)
                  ) {
                  a.splice(j--, 1);
            console.log("I " + a[i].source._id + " " + a[j].source._id + " J");
            } else {
                  console.log(a[i]);
                }
          }
        } else {
          a.splice(i, 1);
        }
      }
      return a;
    };

    // function for drawing rounded rectangles
function roundRect(ctx, x, y, w, h, r)
{
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
    ctx.fill();
	ctx.stroke();
}

function makeTextSprite( message, parameters )
{
	if ( parameters === undefined ) parameters = {};
	
	var fontface = parameters.hasOwnProperty("fontface") ? 
		parameters["fontface"] : "Arial";
	
	var fontsize = parameters.hasOwnProperty("fontsize") ? 
		parameters["fontsize"] : 18;
	
	var borderThickness = parameters.hasOwnProperty("borderThickness") ? 
		parameters["borderThickness"] : 4;
	
	var borderColor = parameters.hasOwnProperty("borderColor") ?
		parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
	
	var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
		parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

		
	var canvas = document.createElement('canvas');
	var context = canvas.getContext('2d');
	context.font = "Bold " + fontsize + "px " + fontface;
    
	// get size data (height depends only on font size)
	var metrics = context.measureText( message );
	var textWidth = metrics.width;
	
	// background color
	context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
								  + backgroundColor.b + "," + backgroundColor.a + ")";
	// border color
	context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
								  + borderColor.b + "," + borderColor.a + ")";

	context.lineWidth = borderThickness;
	roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
	// 1.4 is extra height factor for text below baseline: g,j,p,q.
	
	// text color
	context.fillStyle = "rgba(0, 0, 0, 1.0)";

	context.fillText( message, borderThickness, fontsize + borderThickness);
	
	// canvas contents will be used for a texture
	var texture = new THREE.Texture(canvas) 
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial( 
		{ map: texture } );
	var sprite = new THREE.Sprite( spriteMaterial );
	sprite.scale.set(100,50,1.0);
	return sprite;	
}




    // controls
    const controls = { 'DAG Orientation': 'td'};
    const gui = new dat.GUI();
    gui.add(controls, 'DAG Orientation', ['td', 'bu', 'lr', 'rl', 'zout', 'zin', 'radialout', 'radialin', null])
      .onChange(orientation => graph && graph.dagMode(orientation));
    var startNode = {'StartNode': 'securityScan/102891'};

    var undrawnGraph = {nodes:[], links:[]};

    let controller = new function() {  
        this.securityTests=true;
        this.vulnerabilities=true;
        this.artifacts=true;
        this.images=true;
    }
    let f1 = gui.addFolder('Visible Node Types');
    f1.add(controller, 'vulnerabilities').listen().onChange(value => { 
          vulnerabilities=value;
          graph && filterGraphNodes(graph, controller);
    });
    f1.add(controller, 'artifacts').listen().onChange(value => { 
          artifacts=value;
          graph && filterGraphNodes(graph, controller);
        });

    function filterGraphNodes(graph, nodesTypes) {
      let types = [];
      nodesTypes.securityTests && types.push('securityScan');
      nodesTypes.artifacts && types.push('artifact');
      nodesTypes.images && types.push('dockerImage');
      nodesTypes.vulnerabilities && types.push('vulnerability');
      const updatedNodes = [];
//          fetch('http://127.0.0.1:8529/_db/_system/getting-started/bi-graph/'+encodeURIComponent(startNode.StartNode)).then(res => res.json())
//              .then(data => (!data) ? null : graph.graphData(data));
      let { nodes, links } = graph.graphData();
      nodes = nodes.concat(undrawnGraph.nodes).unique_nodes();
      console.log("links " + links.length);
      links = links.concat(undrawnGraph.links).unique_links();
      console.log("links " + links.length);
      let updatedLinks = [];
      undrawnGraph = {nodes:[], links:[]};
      //let updatedLinks = links.copy();
      for (var i=0;i<nodes.length;i++) {
        if (nodes[i]._id && nodes[i]._id.includes('/')) {
          if (types.includes(nodes[i]._id.split('/')[0])) {
            updatedNodes.push(nodes[i]);
          } else {
            undrawnGraph.nodes.push(nodes[i]);
          }
          //console.log("undraw " + undrawnGraph.nodes.length);
        }
      }
      console.log("links bf" + links.length);
      for (var j=0;j<links.length;j++) {
      //console.log("links " + updatedLinks.length);
        //if (links[j].source._id == nodes[i]._id && links[j].target._id == nodes[i]._id) {
        if (types.includes(links[j].source._id.split('/')[0]) && types.includes(links[j].target._id.split('/')[0])) {
            updatedLinks.push(links[j]);
            //console.log(updatedLinks.length);
          //}
        } else {
          undrawnGraph.links.push(links[j]);
        }
      }
        if (null) {
          undrawnGraph.nodes.push(nodes[i]);
          var curLink;
          for (var j=0;j<updatedLinks.length;j++) {
            //curLink = links[j];
          //while (curLink = links.pop()) {
            //if(links[i]._to == nodes[i]._id || links[i]._from == nodes[i]._id) {
            //console.log(nodes[i]);
            //console.log(curLink);
            if (updatedLinks[j] && nodes[i]) {
              if(updatedLinks[j].source._id == nodes[i]._id || updatedLinks[j].target._id == nodes[i]._id) {
                  undrawnGraph.links.push(updatedLinks[j]);
              } else {
                  updatedLinks.splice(j, 1);
              }
            }
          }
        }
      undrawnGraph = {nodes: undrawnGraph.nodes.unique_nodes(), links: undrawnGraph.links.unique_links()};
      graph.graphData({nodes: updatedNodes.unique_nodes(), links: updatedLinks.unique_links()});
    }
      

    //const gData = {nodes:[{id: 'bad id',_id:'bad/id', name: 'name'}], links:[]};

    //fetch('http://127.0.0.1:8529/_db/_system/getting-started/bi-graph/'+encodeURIComponent(startNode.StartNode)).then(res => res.json()).then(data => { gData['nodes']=data.nodes; gData['links']=data.links });

    // Add a string controller.
    gui.add(startNode, 'StartNode')
      .onFinishChange(node => graph && 
          fetch(baseUrl+'bi-graph/'+encodeURIComponent(node)).then(res => res.json())
              .then(data => (!data) ? null : graph.graphData(data))
          );
    //console.log("gData links " + gData.links.length.toString());
    //console.log("gData nodes " + gData['nodes'].length);
    const elem = document.getElementById('3d-graph');
    let distance = 800;
    let focusedNode = null
    const graph = ForceGraph3D()
      (elem)
        .jsonUrl(baseUrl+'bi-graph/'+encodeURIComponent(startNode.StartNode))
        .nodeLabel(d => d.name)
        .linkDirectionalParticles('value')
        .backgroundColor('black')
        .linkDirectionalParticleSpeed(d => d.value * 0.001)
        .linkWidth(3)
        .linkDirectionalParticleWidth(2)
        //.nodeColor(node =>  {
        //  if (node._id.split('/')[0] == 'vulnerability') {
        //    return 'red';
        //  }
        //})
        .nodeThreeObject(node => {
	  const labelString = node.get("name", "");
          const label = new SpriteText(labelString);
          label.material.depthWrite = false; // make sprite background transparent
          label.textHeight = 0.25;
          //if (node._id.split('/')[0] != 'vulnerability') {
            const imgTexture = new THREE.TextureLoader().load(baseUrl+'icons/'+node._id.split('/')[0]+'.svg');
            const material = new THREE.SpriteMaterial({ map: imgTexture });
            const sprite = new THREE.Sprite(material);
            sprite.material.depthWrite = false;
            sprite.scale.set(12, 12);
            label.position.y = label.textHeight * 5;
            label.position.z = label.textHeight * 0.9;
            label.position.x = label.textHeight * 0.9;
            sprite.add(makeTextSprite('test', { fontsize: 24, borderColor: {r:255, g:0, b:0, a:1.0}, backgroundColor: {r:255, g:100, b:100, a:0.8} }));
            return sprite;
          //}
        })
        //.nodeThreeObjectExtend(true)
        .onNodeClick(node => {
          let { nodes, links } = graph.graphData();
          fetch(baseUrl+'graph/'+encodeURIComponent(node._id)).then(res => res.json()).then(data => {
            if (data.nodes &&  data.links) {
              graph.graphData({nodes: nodes.concat(data.nodes).unique_nodes(), links: links.concat(data.links).unique_links()})
            }
          });
        })
        .onNodeRightClick(node => {
          // Aim at node from outside it
          distance = 200;
          const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

          graph.cameraPosition(
            { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio * 2 }, // new position
            node, // lookAt ({ x, y, z })
            3000  // ms transition duration
          );

          let { nodes, links } = graph.graphData();
          fetch(baseUrl+'node/'+encodeURIComponent(node._id)).then(res => res.json()).then(data => node = data[0]);
          graph.refresh();
        });
        // Spread nodes a little wider
        graph.d3Force('charge').strength(-240);

  </script>
</body>
